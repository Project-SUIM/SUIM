package coffee.axle.suim.feature.exploit;

import coffee.axle.suim.feature.Feature;

import coffee.axle.suim.events.*;
import coffee.axle.suim.util.MyauLogger;
import coffee.axle.suim.util.PacketUtils;
import coffee.axle.suim.util.Utils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.*;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * BufferVelocity
 */
public class VelocityBuffer extends Feature {
    private static final Minecraft mc = Minecraft.getMinecraft();

    private Object moduleInstance;
    private Object renderTimerProperty;

    private int color = new Color(209, 1, 1, 255).getRGB();
    private List<Map<String, Object>> packets = new ArrayList<>();
    public boolean delaying = false;
    private int timeout = 0;
    private boolean s08;

    @Override
    public String getName() {
        return "BufferVelocity";
    }

    @Override
    public boolean initialize() {
        try {
            moduleInstance = createModule();
            creator.injectModule(moduleInstance, VelocityBuffer.class);
            renderTimerProperty = creator.createBooleanProperty("timer", false);
            creator.registerProperties(moduleInstance, renderTimerProperty);
            manager.reloadModuleCommand();
            MinecraftForge.EVENT_BUS.register(this);

            manager.registerModuleCallbacks(
                    moduleInstance,
                    () -> onModuleEnabled(),
                    () -> onModuleDisabled());

            return true;
        } catch (Exception e) {
            MyauLogger.error("VelocityBuffer:init", e);
            return false;
        }
    }

    private void onModuleDisabled() {
        flush();
    }

    private void onModuleEnabled() {
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onReceivePacket(ReceivePacketEvent e) {
        if (!manager.isModuleEnabled("BufferVelocity"))
            return;
        if (!Utils.nullCheck()) {
            return;
        }

        @SuppressWarnings("rawtypes")
        Packet p = e.getPacket();

        if (!delaying && p instanceof S08PacketPlayerPosLook) {
            s08 = true;
        }

        if (p instanceof S12PacketEntityVelocity) {
            if (((S12PacketEntityVelocity) p).getEntityID() == mc.thePlayer.getEntityId()) {
                S12PacketEntityVelocity s12 = (S12PacketEntityVelocity) p;
                if (s08) {
                    s08 = false;
                    return;
                }
                if (s12.getEntityID() == mc.thePlayer.getEntityId()) {
                    delaying = true;
                }
            }
        }

        if (!delaying || !(p instanceof S12PacketEntityVelocity
                || p instanceof S32PacketConfirmTransaction
                || p instanceof S08PacketPlayerPosLook)) {
            return;
        }

        Map<String, Object> entry = new HashMap<>();
        entry.put("packet", p);
        entry.put("time", Utils.time());

        synchronized (packets) {
            packets.add(entry);
        }

        e.setCanceled(true);
    }

    @SubscribeEvent(priority = EventPriority.NORMAL)
    public void onPostMotion(PostMotionEvent e) {
        if (!manager.isModuleEnabled("BufferVelocity"))
            return;

        if (delaying && ++timeout >= 300) {
            flush();
            manager.sendMessage("&BufferVelocity timed out.");
        }
        s08 = false;
    }

    @SubscribeEvent
    public void onRenderTick(TickEvent.RenderTickEvent ev) {
        if (!manager.isModuleEnabled("BufferVelocity"))
            return;
        if (!Utils.nullCheck() || timeout == 0)
            return;

        try {
            boolean renderTimer = (Boolean) properties.getPropertyValue(renderTimerProperty);
            if (!renderTimer)
                return;
        } catch (Exception e) {
            return;
        }

        if (ev.phase == TickEvent.Phase.END) {
            if (mc.currentScreen != null) {
                return;
            }
        }

        ticksTimer(timeout);
    }

    private void ticksTimer(int ticks) {
        int widthOffset = (ticks < 10) ? 4
                : (ticks >= 10 && ticks < 100) ? 7 : (ticks >= 100 && ticks < 1000) ? 10 : (ticks >= 1000) ? 13 : 16;

        String text = String.valueOf(ticks);
        int width = mc.fontRendererObj.getStringWidth(text);

        final ScaledResolution scaledResolution = new ScaledResolution(mc);
        int[] display = {
                scaledResolution.getScaledWidth(),
                scaledResolution.getScaledHeight(),
                scaledResolution.getScaleFactor()
        };

        float yadd = 8;

        mc.fontRendererObj.drawString(text, display[0] / 2 - width + widthOffset,
                display[1] / 2 + (int) yadd, color, true);
    }

    @SuppressWarnings("unchecked")
    void flush() {
        if (packets.isEmpty()) {
            delaying = false;
            timeout = 0;
            return;
        }

        while (!packets.isEmpty()) {
            synchronized (packets) {
                if (packets.isEmpty())
                    break;
                Map<String, Object> entry = packets.remove(0);
                @SuppressWarnings("rawtypes")
                Packet packet = (Packet) entry.get("packet");

                PacketUtils.skipReceiveEvent.add(packet);

                try {
                    packet.processPacket(mc.getNetHandler());
                } catch (Exception e) {
                    MyauLogger.error("VelocityBuffer:tick", e);
                }
            }
        }

        delaying = false;
        timeout = 0;
    }
}
